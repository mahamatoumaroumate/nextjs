# More Root

Private Folders \_folder
Route Groups (dashboard)

Dynamic Routes

[...folder] - Catch-all route segment
[[...folder]] Optional catch-all route segment (used by Clerk)
create test folder app/\_css

create app/(dashboard)/auth

the url is just '/auth'
create app/(dashboard)/auth/[sign-in]

# Prisma Sqlite

Prisma ORM is a database toolkit that simplifies database access in web applications. It allows developers to interact with databases using a type-safe and auto-generated API, making database operations easier and more secure.

Prisma server: A standalone infrastructure component sitting on top of your database.
Prisma client: An auto-generated library that connects to the Prisma server and lets you read, write and stream data in your database. It is used for data access in your applications.

npm install prisma --save-dev
npm install @prisma/client

npx prisma init

This creates a new prisma directory with your Prisma schema file and configures SQLite as your database. You're now ready to model your data and create your database with some tables.

generator client {
provider = "prisma-client-js"
}

datasource db {
provider = "sqlite"
url = env("DATABASE_URL")
}

# ADD .ENV TO .GITIGNORE !!!!

.env

# Setup instance

In development, the command next dev clears Node.js cache on run. This in turn initializes a new PrismaClient instance each time due to hot reloading that creates a connection to the database. This can quickly exhaust the database connections as each PrismaClient instance holds its own connection pool.

(Prisma Instance)[https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution]

create utils/db.ts
import { PrismaClient } from '@prisma/client';

const prismaClientSingleton = () => {
return new PrismaClient();
};

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;

const globalForPrisma = globalThis as unknown as {
prisma: PrismaClientSingleton | undefined;
};

const prisma = globalForPrisma.prisma ?? prismaClientSingleton();

export default prisma;

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

# Prisma Model

The Prisma model provided is a representation of a Task entity in the context of a database schema. Here's a detailed description of each component within this model:

model Task { ... }: This is the definition of the Task model. In Prisma, a model represents a table in the database. It serves as a blueprint for the records that will be stored in the corresponding table, defining the structure and behavior of the data.

id String @id @default(uuid()): This line defines a field named id of type String which is marked with @id, signifying that this field is the primary key of the model. The @default(uuid()) directive indicates that the default value for this field will be a UUID (Universally Unique Identifier) generated by Prisma.

content String: This line declares a field named content of type String. This field will store textual data, presumably the details or description of the task.

createdAt DateTime @default(now()): This field is named createdAt and is of type DateTime. It has a default value set to the current timestamp at the time of record creation, indicated by the @default(now()) directive.

completed Boolean @default(false): Lastly, the completed field is of type Boolean and is used to indicate whether the task has been completed. It defaults to false, meaning when a new task record is created, it is considered incomplete by default.

In Prisma, the term "model" refers to an abstraction that maps to a table in your database. Prisma models are defined in the Prisma schema, which is a declarative representation of your database's structure. Each model in the Prisma schema corresponds to a table in the database, and each field within a model corresponds to a column in that table. This schema plays a central role in Prisma's features, such as type-safe database access and migrations.

# safely applies and tracks changes to the database structure.

npx prisma migrate dev

# in a new terminal window

launch Prisma Studio, which is a visual editor for your database.
http://localhost:5555
npx prisma studio

# Optional - Prisma Crud

Prisma Docs

- Create Single Record
  const task = await prisma.task.create({
  data: {
  content: 'some task',
  },
  });
- Get All Records
  const tasks = await prisma.task.findMany();
- Get record by ID or unique identifier
  // By unique identifier
  const user = await prisma.user.findUnique({
  where: {
  email: 'elsa@prisma.io',
  },
  });

- By ID
  const task = await prisma.task.findUnique({
  where: {
  id: id,
  },
  });
- Update Record
  const updateTask = await prisma.task.update({
  where: {
  id: id,
  },
  data: {
  content: 'updated task',
  },
  });
- Update or create records
  const upsertTask = await prisma.task.upsert({
  where: {
  id: id,
  },
  update: {
  content: 'some value',
  },
  create: {
  content: 'some value',
  },
  });
- Delete a single record
  const deleteTask = await prisma.task.delete({
  where: {
  id: id,
  },
  });

# Server Actions

- asynchronous server functions that can be called directly from your components.

- typical setup for server state mutations (create, update, delete)

- endpoint on the server (api route on Next.js)
  make request from the front-end
  setup form, handle submission etc
  Next.js server actions allow you to mutate server state directly from within a React component by defining server-side logic alongside client-side interactions.

- Rules :

must be async
add 'use server' in function body
use only in React Server Component
export default function ServerComponent() {
async function myAction(formData) {
'use server';
// access input values with formData
// formData.get('name')
// mutate data (server)
// revalidate cache
}

return <form action={myAction}>...</form>;
}

# UseFormStatus && UseFormState

'use client';
import { createTaskCustom } from '@/utils/actions';
import { useFormStatus, useFormState } from 'react-dom';
// The useFormStatus Hook provides status information of the last form submission.
// useFormState is a Hook that allows you to update state based on the result of a form action.

const SubmitButton = () => {
const { pending } = useFormStatus();

return (
<button
      type='submit'
      className='btn join-item btn-primary'
      disabled={pending}
    >
{pending ? 'please wait... ' : 'create task'}
</button>
);
};

const initialState = {
message: null,
};

const TaskForm = () => {
const [state, formAction] = useFormState(createTaskCustom, initialState);

return (

<form action={formAction}>
{state.message ? <p className='mb-2'>{state.message}</p> : null}
<div className='join w-full'>
<input
          className='input input-bordered join-item w-full'
          placeholder='Type Here'
          type='text'
          name='content'
          required
        />
<SubmitButton />
</div>
</form>
);
};
export default TaskForm;

# Extra - More User Input Validation Options

required attribute a great start
zod library
The Zod library is a TypeScript-first schema declaration and validation library that allows developers to create complex type checks with simple syntax.

- npm install zod
- actions
  import { z } from 'zod';

export const createTaskCustom = async (prevState, formData) => {
await new Promise((resolve) => setTimeout(resolve, 2000));
const content = formData.get('content');

const Task = z.object({
content: z.string().min(5),
});

// some validation here
try {
Task.parse({
content,
});
await prisma.task.create({
data: {
content,
},
});
// revalidate path
revalidatePath('/tasks');
return { message: 'success!!!' };
} catch (error) {
console.log(error);
// can't return error
return { message: 'error...' };
}
};

# Providers

- npm install react-hot-toast
- create providers.js file in app
  'use client';
  import { Toaster } from 'react-hot-toast';

const Providers = ({ children }) => {
return (
<>
<Toaster />
{children}
</>
);
};
export default Providers;

- layout.js
  import Providers from './providers';
  export default function RootLayout({ children }) {
  return (
  <html lang='en'>
  <body className={inter.className}>
  <Navbar />
  <main className='px-8 py-20 max-w-6xl mx-auto'>
  <Providers>{children}</Providers>
  </main>
  </body>
  </html>
  );
  }

# Route Handlers

install Thunder Client
Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

in app create folder "api"
in there create folder "tasks" with route.js file
The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.

In addition to supporting native Request and Response. Next.js extends them with NextRequest and NextResponse to provide convenient helpers for advanced use cases.

app/api/tasks/route.js
// the following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called, Next.js will return a 405 Method Not Allowed response.

import { NextResponse } from 'next/server';
import db from '@/utils/db';

export const GET = async (request) => {
const tasks = await db.task.findMany();
return Response.json({ data: tasks });
// return NextResponse.json({ data: tasks });
};

export const POST = async (request) => {
const data = await request.json();
const task = await db.task.create({
data: {
content: data.content,
},
});
return NextResponse.json({ data: task });
};

# Middleware

Middleware in Next.js is a piece of code that allows you to perform actions before a request is completed and modify the response accordingly.

create middleware.js in the root
by default will be invoked for every route in your project
export function middleware(request) {
return Response.json({ msg: 'hello there' });
}

export const config = {
matcher: '/about',
};

import { NextResponse } from 'next/server';

// This function can be marked `async` if using `await` inside
export function middleware(request) {
return NextResponse.redirect(new URL('/', request.url));
}

// See "Matching Paths" below to learn more
export const config = {
matcher: ['/about/:path*', '/tasks/:path*'],
};

# PlanetScale

- Host DB

- set DATABASE_URL in .env
  generator client {
  provider = "prisma-client-js"
  }
  datasource db {
  provider = "mysql"
  url = env("DATABASE_URL")
  relationMode = "prisma"
  }

- npx prisma db push

# Local Build

- Setup App
- package.json
  "build": "npx prisma generate && next build",
- clean out the Database
- npm run build
- npm run dev

# Force Dynamic

- tasks.js
  export const dynamic = 'force-dynamic';

# Deploy
